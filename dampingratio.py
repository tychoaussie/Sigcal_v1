__author__ = "Daniel Burk <burkdani@msu.edu>"
__version__ = "20140814"
__license__ = "MIT"

import os, sys, csv
from scipy import signal
from scipy.integrate import simps
import pylab as plt
import numpy as np
import scipy as sp


                                           # import time, string
                                           # from obspy.core import read, Trace, Stream, UTCDateTime
                                           # from obspy.sac import SacIO
class Dampingratio(object):
    '''Dampingratio is a utility for measuring the seismometer damping ratio.
       It will return an average damping ratio representing the first three
       oscillations of the transient.
       
        

       Syntax: dampingratio target_file

       

       Typical useage:
       <ObsPy> C:\Python27\scripts> python dampingratio.py c:/calibration/station/ 

    '''

                                   #                       Function load:
 
                                   # load the csv infile as generated by DAT2ASC with csv option
def load(infile):                                    
    with open(infile,'r') as fin:
        list = csv.reader(fin)
        rowcnt=0
        stack = []
        header = []
        for row in list:           # Bring in the data and create a list of lists, each of which                                  
            if rowcnt == 0:        # corresponds with a given sample.
                header.append(row)
            else:
                stack.append(row)
            rowcnt = 1
    return (header,stack)


                                   # Create a low pass filter to be applied to the signal and laser
                                   # in order reduce interference from 50 or 60 hz hum and stuff like that
                                   #

def firfilt(interval, freq, sampling_rate):  # Interval is the array upon which you wish to apply the low pass filter
    nfreq = freq/(0.5*sampling_rate)
    taps =  sampling_rate + 1
    a = 1
    b = sp.signal.firwin(taps, cutoff=nfreq)
    firstpass = sp.signal.lfilter(b, a, interval)
    secondpass = sp.signal.lfilter(b, a, firstpass[::-1])[::-1]
    return secondpass                                  

                                   #                       Function getconstants:


def getconstants(calcontrol):      # From calcontrol file, retrieve the list of constants 
    constants = load(calcontrol)   # that relate these measurements to the real world.
    constant = constants[1][0]        # constants[0] contains headers that we don't really use
                                   # constant[0] = (text) Station: 'station name'
                                   # constant[1] = (float) adccal[0]: cal constant for ch 0 (microvolts / count)
                                   # constant[2] = (float) adccal[1]: cal constant for ch 1 (microvolts / count)
                                   # constant[3] = (float) adccal[2]: cal constant for ch 2 (microvolts / count)
                                   # constant[4] = (float) adccal[3]: cal constant for ch 3 (microvolts / count)
                                   # constant[5] = (float) laserres: cal constant for the laser ( mV / micron)
                                   # constant[6] = (float) lcalconst: cal constant for geometry correction factor
                                   # constant[7] = (float) h: Damping ratio for the seismometer as measured by engineer.
                                   # constant[8] = (float) resfreq: Free period resonance freq. as measured by engineer.
    return(constant)


def scatter_comparison():
    '''exponential function, y = exp(0.05 x)'''
 
    # prepare data points
    # plot it
    
    plt.loglog(F1, S1, "*", F2, S2, "+") #, F3, S3, "*")     # the "." means draw points instead of lines
    plt.xlabel("Frequency")
    plt.ylabel("Sensitivity in V/m/sec")
    plt.title("Comparison of sensitivity curves")
    plt.annotate("* = derivative data", xy=(10,5), xytext=(3,1),
                 arrowprops=dict(facecolor='black',shrink=0.05))
    plt.annotate("+ = integral data", xy=(.1,.1), xytext=(1,.1),
                 arrowprops=dict(facecolor='green',shrink=0.05))
#    plt.annotate("* = Signal hybrid", xy = (.1,.1), xytext = (1,.01),
#                 arrowprops=dict(facecolor='red',shrink=0.05))
    plt.show()
    
def graph_curve(time,counts,resfreq):
    plt.plot(time,counts)
    plt.xlabel("Time (in seconds)    Free period frequency = {:.3f} Hz".format(resfreq))
    plt.ylabel("Counts")
    plt.show()

def graph_curve2(X,Y,Ylabel,Y1,ylabel1):
    plt.plot(X,Y, '-b', label = Ylabel)
    plt.plot(X,Y1, '-r', label = Ylabel1)
    plt.xlabel("Samples")
    plt.ylabel("Counts")
    plt.show()

def process(infile,calfile):

    fdata = load(infile)     # Load the infile currently loaded with 1 Hz data
    header = fdata[0]
    adccal = [1.0,1.0,1.0,1.0]

    constant = getconstants(calfile)         # Retrieve the constants from the file

    Station = constant[0]                    # Name of Station under test
    for i in range(0,4):
        adccal[i] = float(constant[i+1])     # Calibration constants for the ADC channels as measured by engineer
                                             # for this particular system. Each one is unique.
    laserres = float(constant[5])            # CALIBRATED value from laser position sensor in mV/micron
    lcalconst = float(constant[6])           # Typ. 1.022, for the SM3, based on the geometry of the laser target 
                                             # and center of coil relative to radius of moment arm
    h = float(constant[7])                   # typically about 0.7 but MUST be accurately measured beforehand!
    resfreq = float(constant[8])             # Typically between 0.7 and 1.3 Hz. Expressed in Hz, not seconds.
    Rn = (np.pi * 2.0 * resfreq)             # Free period as expressed in radians / second                      
    lasercal = laserres/1000                 # microns / count from the CALIBRATED laser and CALIBRATED ADC.


    print 'This program is designed to assist you in the measurement of the damping ratio.\n'
    print ' You should have a csv file that represents several damping ratio impulses.' 
    print ' The following screens will open and enable you to plot the waveform within'
    print ' the file. The data is filtered with a low-pass filter to 10 Hz. For each'
    print ' impulse, measure the sample number representing the downslope of the '
    print ' first impulse as well as the sample number representing the end of the'
    print ' level part of the ending part of the wave where signal is flat.\n' 
    print ' The program will enable you to enter these sample numbers for as many impulses'
    print ' as you have within the file.\n\n'
    print ' The program will calculate the damping ratios as the average of Z1 to Z2,'
    print ' and Z2 to Z3, then make an average damping ratio from the impulses. '

    schan = int(raw_input('\n Enter the channel num. for the seismic sensor (usually ch. 1 through 3)'))
    rchan = int(raw_input('Enter the channel num. for the laser position sensor (usually channel 4)'))
                                             # Parse out the sensor and laser data
    sensor = [] 
    laser = []
    for i in range(0,len(fdata[1])):
        sensor.append(int(fdata[1][i][schan], base=10))
        laser.append(int(fdata[1][i][rchan], base=10))

                                             # Calculate the sample period based on the timing channels (in seconds)

    delta = ((float(fdata[1][len(fdata[1])-1][12])+float(fdata[1][len(fdata[1])-1][15]))-(float(fdata[1][0][12])+float(fdata[1][0][15])))/len(fdata[1])

    laser = firfilt(laser,10,1/delta)
    sensor = firfilt(sensor,10,1/delta)
                                             # Apply a high pass filter to remove any high-frequency interference from signal

    # laser = sp.signal.symiirorder1(laser,4,.8) # Adjust the signal for DC bias of laser, then filter.
    lasermean = np.mean(laser[(len(laser)-2048):len(laser)]) # Take the DC bias measurement fm end of signal
    laser[:] = [x-int(lasermean) for x in laser]
    
                                      #
                                      # I am not yet able to auto process these files
                                      # Therefore we'll open the graph, plot the whole waveform
                                      # and let the user pick the starting sample point.
                                      # Then we'll process frequency from there.


    x = []
    for i in range (0,len(laser)):
        x.append(i)
    plt.plot(x,sensor)
    plt.show()

    impnum = int(raw_input('\n\n How many impulses have you measured? '))
    last = []
    first = []
    for i in range (1,impnum+1):
        first.append(int(raw_input('\n Enter the estimated sample number of the beginning of the impulse {}  '.format(i))))
        last.append(int(raw_input('Enter the estimated sample number of the ending of the impulse train {} '.format(i))))


    ##########################################################
    hn = []
    for i in range(0,impnum):

        sense = sensor[first[i]:last[i]]
        sgrad = np.gradient(sense,80)
                                  # sgrad is the derivative of the sensor: Scan for zero crossings
        sgfilt = sp.signal.symiirorder1(sgrad,4,.8)
        Z = []                            # Z is the list of sensor values corresponding to where the derivative flips sign,
        ZZ = []                           # and should represent where the local max/min occurred in the waveform.
        offset = np.mean(sense[(len(sense)-131):len(sense)])   # Use the tail to determine the zero point of the impulse          
        polarity = 0
        zero_crossings = np.where(np.diff(np.sign(sgfilt)))[0]  
        for n in range(0,len(zero_crossings)):
           Z.append(sense[zero_crossings[n]]-offset) # Z represents the actual peak sample where the derivative went to zero and is offset corrected
                                       #    print sense[zero_crossings[i]]
        for n in range(0,len(Z)-1):
            zz = np.abs(Z[n])       # zz is the absolute value of the signal datapoint
            ZZ.append(zz)             # ZZ is the list of absolute values from Z
                                  # Adjust Z for middle tail-end to fix bias problems
                                               # Calculate the list of "good" points based on the fact that each value should 
                                               # be smaller than the next 
        nn = 0
        flag = True
  
        for n in range(1,len(ZZ)):
                if np.int(ZZ[n])>np.int(ZZ[n-1]):
                    flag = False
                else:
                    if flag == True:
                        nn +=1
            
        hh = []
        for n in range(1,nn):              # calculate a list of damping ratios starting with the second local max
            hh.append(np.log(np.abs(float(Z[n-1])/Z[n])) / np.sqrt(np.square(np.pi)+np.log(np.abs(float(Z[n-1])/Z[n]))))
        hn.append(np.mean(hh))
        print '\n Damping ratios for impulse {0} that create a mean of {1:0.3f} are as follows: '.format(i,np.mean(hh))
        print hh 
    hm = np.median(hn)
    ha = np.mean(hn)
    print '\n\n The median damping ratio for your {0} impulses = {1:0.3f} . '.format(impnum,h)
    print '\n The mean damping ratio for your {0} impulses = {1:0.3f} . '.format(impnum,ha)

    



def main():
                                      #           MAIN PROGRAM BODY
                                      #  Parse the command line switches
                                      # Commmand example: c:\Python27>Python.exe Sigcal.py c:\seismo\caldata\momo
                                      # where momo is the working directory containing the csv files
                                      # as well as the calibration control file, c:\seismo\caldta\calcontrol.csv
                                      # The third option can designate an optional location for the calcontrol file.
                                      #
    optioncount = len(sys.argv)
    outputfile_defined = False
    filelist = []
    dir=""
    outfile = os.getcwd()+"\calibration_freeperiod_report.cal"
    calfile = os.getcwd()+"\calcontrol.cal"

    if optioncount > 1:
        if optioncount == 2:
            calfile = os.getcwd()+"\calcontrol.cal"

            if "." in sys.argv[1]:
                infile = sys.argv[1]
    else:
        print " This program requires that you input a file representing a calibration impulse for damping ratio calculation."
        exit()
    
    process(infile,calfile)                                                     


#
# Check and run the main function here:
#
if __name__ == '__main__':
  main()
