__author__ = "Daniel Burk <burkdani@msu.edu>"
__version__ = "20150112"
__license__ = "MIT"

# NEW VERSION for testing revised signal processing techniques.
# Use FFT for finding the RMS of the signals,
# then use 2*pi*f to compare relationship of signal to derivative of
# the laser position.
# Break the waveform into 4096 sample chunks and process them.
# Then, look at the standard deviation and use the chunk with the
# lowest dtandard deviation for determining sensitivity.

# 20141114 version: Move the file construction out of the process loop, and instead, pass
# the raw parameters into main, where they are then assembled into an array
# and file. Then, use the array directly with grid searching for determining 
# the optimum damping ratio that fits the curve, and then write out the final
# file, based on the optimized damping ratio.

# This prepares the code for use in internalizing the curve calculations.
# The next iteration of code likely will pass the UNCOMPENSATED ground motion curve 
# into the grid search algorithm so that we won't have to know what the damping
# ratio is. Rather, we'll use the shape of the calibration curve and a grid search
# to model the theoretical damping ratio that best describes the behavior of the
# transducer. This should be the practical damping ratio of the whole system.

# 11/25/2014 - fixed the problem with free period going into the grid search as a
# frequency rather than a period.
# - Rev b: Constrained the grid search to use the MSU measured free period AND damping
# when doing a grid search because of demonstrated dependency on damping ratio as
# affecting the results of the initial sensitivity curve. Improve at a later date.

# 12jan2015 - minor bug fixes to file paths on output



import os, sys, csv
from scipy import signal
from scipy.integrate import simps
import pylab as plt
import numpy as np
import scipy as sp
import time, string
import grid_search                         # Grid_search created by Hans Hartse, LANL
                                           # This module must be installed in the python lib
                                           # directory that is referenced by whatever python
                                           # you are running. It also has an Obspy dependency
                                           # So Obspy must be installed for it to run.
                                           # If you are running this in ipython notebooks
                                           # grid_search.py must be installed in c:/Anaconda/lib

                                           # from obspy.core import read, Trace, Stream, UTCDateTime
                                           # from obspy.sac import SacIO


class Sigcal(object):
    '''Sigcal is a utility for converting ascii files generated by 
       the 2010 version of DAT2ASC's csv output that represent a series of sinusoidal
       signals which were excited by a calibration coil and recorded simultaneously
       on the seismometer velocity coil and with a laser position sensor that tracks
       actual movement of the seismometer mass. By comparing the seismometer signal
       to the laser position, it is possible to determine the sensitivity at that 
       frequency. This program takes a series of files representing frequencies across
       the instrument passband and uses them to create a calibration response curve.
       There are some initial constants that are required in order to process these
       files. They are found within the file called 'calconst.cal' which is invoked
       by this program. This file should exist within the parent directory that
       also contains all the csv files. 
        

       Syntax: Sigcal target_directory (outfile_name) (calconst.cal_alternate_name) 

       

       Typical useage:
       <ObsPy> C:\Python27\scripts> python Sigcal.py c:/calibration/station/ [outfputfile] [calconstfile]

    '''




                                   #                       Function load:
 
                                   # load the csv infile as generated by DAT2ASC with csv option
def load(infile):                                    
    with open(infile,'r') as fin:
        list = csv.reader(fin)
        rowcnt=0
        stack = []
        header = []
        for row in list:           # Bring in the data and create a list of lists, each of which                                  
            if rowcnt == 0:        # corresponds with a given sample.
                header.append(row)
            else:
                stack.append(row)
            rowcnt = 1
    return (header,stack)





                                   #                       Function getconstants:

def getconstants(calcontrol):      # From calcontrol file, retrieve the list of constants 
    constants = load(calcontrol)   # that relate these measurements to the real world.
    constant = constants[1][0]        # constants[0] contains headers that we don't really use
                                   # constant[0] = (text) Station: 'station name'
                                   # constant[1] = (float) adccal[0]: cal constant for ch 0 (microvolts / count)
                                   # constant[2] = (float) adccal[1]: cal constant for ch 1 (microvolts / count)
                                   # constant[3] = (float) adccal[2]: cal constant for ch 2 (microvolts / count)
                                   # constant[4] = (float) adccal[3]: cal constant for ch 3 (microvolts / count)
                                   # constant[5] = (float) laserres: cal constant for the laser ( mV / micron)
                                   # constant[6] = (float) lcalconst: cal constant for geometry correction factor
                                   # constant[7] = (float) h: Damping ratio for the seismometer as measured by engineer.
                                   # constant[8] = (float) resfreq: Free period resonance freq. as measured by engineer.
    return(constant)

def plot_curve(Station,Frequencies,Sensitivities,Freeperiod,h):
    
 
    # prepare data points
    # plot it
    
    plt.loglog(Frequencies, Sensitivities, "*")     # "*" means draw asterisk instead of lines
    plt.xlabel("Free period = {0:.2f} Hz           Frequency in Hz             Damping Ratio = {1:.3f}".format(Freeperiod,h))
    plt.ylabel("Sensitivity in V/m/sec")
    plt.title("Sensitivity curve for station "+Station+" on "+time.asctime())
#    plt.annotate("Free period = {:.1f} Hz".format(Freeperiod), xy=(0.02,0.02),xytext=(0.02,0.02))
#    plt.annotate("Damping Ratio = {:.3f}".format(h), xy=(1,.02),xytext=(1,.02))
#    plt.annotate("* = sensitivity measurement points", xy=(10,5), xytext=(3,1),
#                 arrowprops=dict(facecolor='black',shrink=0.05))

    plt.show()

def plot_curve2(Station,Frequencies,Calint,Calderiv,Freeperiod,h):
    
 
    # prepare data points
    # plot it
    
    plt.loglog(Frequencies, Calint, "*", Frequencies,Calderiv,"+")     # "*" means draw asterisk instead of lines
    plt.xlabel("Free period = {0:.2f} Hz           Frequency in Hz             Damping Ratio = {1:.3f}".format(Freeperiod,h))
    plt.ylabel("Sensitivity in V/m/sec")
    plt.title("Sensitivity curve for station "+Station+" on "+time.asctime())
#    plt.annotate("Free period = {:.1f} Hz".format(Freeperiod), xy=(0.02,0.02),xytext=(0.02,0.02))
#    plt.annotate("Damping Ratio = {:.3f}".format(h), xy=(1,.02),xytext=(1,.02))
    plt.annotate("* = sensitivity from int(sensor)/laser", xy=(10,5), xytext=(3,1),
                 arrowprops=dict(facecolor='black',shrink=0.05))
    plt.annotate("* = sensitivity from int(sensor)/laser", xy=(10,5), xytext=(3,1),
                 arrowprops=dict(facecolor='black',shrink=0.05))


    plt.show()


                                      #                    Function process:

def process(infile,calfile):

    fdata = load(infile)     # Load the current infile
    outlog = calfile[:string.find(calfile,'.')]+".log" 
#    print outlog
    header = fdata[0]
    adccal = [1.0,1.0,1.0,1.0]

    constant = getconstants(calfile)         # Retrieve the constants from the file

    Station = constant[0]                    # Name of Station under test
    for i in range(0,4):
        adccal[i] = float(constant[i+1])     # Calibration constants for the ADC channels as measured by engineer
                                             # for this particular system. Each one is unique.
    laserres = float(constant[5])            # CALIBRATED value from laser position sensor in mV/micron
    lcalconst = float(constant[6])           # Typ. 1.022, for the SM3, based on the geometry of the laser target 
                                             # and center of coil relative to radius of moment arm
    h = float(constant[7])                   # typically about 0.7 but MUST be accurately measured beforehand!
    resfreq = float(constant[8])             # Typically between 0.7 and 1.3 Hz. Expressed in Hz, not seconds.
    Rn = (np.pi * 2.0 * resfreq)             # Free period as expressed in radians / second                      
    lasercal = laserres/1000                 # microns / count from the CALIBRATED laser and CALIBRATED ADC.

                                             # Parse out the sensor and laser data
    sensor = [] 
    laser = []

    lchannel = 3                             # The channel used with the laser
    schannel = 2                             # The channel on which the sensor resides

    for i in range(0,len(fdata[1])):
        sensor.append(int(fdata[1][i][schannel+1], base=10))
        laser.append(int(fdata[1][i][lchannel+1], base=10))

                                             # Calculate the sample period based on the timing channels (in seconds)

    delta = ((float(fdata[1][len(fdata[1])-1][12])+float(fdata[1][len(fdata[1])-1][15]))-(float(fdata[1][0][12])+float(fdata[1][0][15])))/len(fdata[1])

                                      #            
                                      # Find the period of the observed signal
                                      #
    #    sense = signal.detrend(sensor)
    # Create a head and tail for the file of 4096 sample apiece.
    # We will create two ratios, from the head and tail of the file
    # and use the one with the lowest standard deviation for determining
    # the one for use with the FFT
    #
    sensor = signal.detrend(sensor)
    laser = signal.detrend(laser)
    sensor1 = []
    sensor2 = []
    laser1 = []
    laser2 = []
    for i in range(0,4096):
        sensor1.append(sensor[i]) # take the first 4096 samples
        sensor2.append(sensor[(len(sensor)-4096+i)]) # Take the last 4096 samples
        laser1.append(laser[i]) # take the first 4096 samples
        laser2.append(laser[(len(laser)-4096+i)]) # take the last 4096 samples
    
    ratio1 = np.std(sensor1)*np.std(laser1)
    ratio2 = np.std(sensor2)*np.std(laser2)
    if ratio1<ratio2: # The chunk with the smallest standard deviation wins.
        sensor3 = sensor1
        laser3 = laser1
    else:
        sensor3 = sensor2
        laser3 = laser2
                         # Apply the ADC constants to the sensor channel data to convert to units of volts
    sensor3 = adccal[schannel]*np.array(sensor3)
                         # Apply an FFT to the sensor data
                         # Generate a frequency table
                         # Find the index point where rms energy is highest
                         # Return the frequency in Hz.
    senfft   = np.fft.fft(sensor3)
    freq = np.fft.fftfreq(len(sensor3),delta) # Length of the sample set and delta is the samplerate
    idx = np.where(abs(senfft)==max(np.abs(senfft)))[0][-1]
    Frequency = abs(freq[idx])
   
                                      #
                                      # Take the sample with the largest amplitude as our center frequency. 
                                      # This only works if the signal is heavily sinusoidal and stationary 
                                      # in nature, like our calibration data.
                                      #
    period = 1/(Frequency*delta) # represents the number of samples for one cycle of the test signal.
    gmcorrect = (2*np.pi*Frequency)**2/np.sqrt((Rn**2-(2*np.pi*Frequency)**2)**2+(4*h**2*(2*np.pi*Frequency)**2*Rn**2))

                                      #
                                      # create an axis representing time.
                                      #

    dt = [] # Create an x axis that represents elapsed time in seconds. delta = seconds per sample, i represents sample count
    for i in range(0,len(sensor)):
        dt.append(i*delta)

                                      # gmcorrect is the correction factor for observed pendulum motion 
                                      # vs true ground motion.
                                      # Now compensate the laser signal.

    gmotion = adccal[lchannel]*lasercal*lcalconst/gmcorrect*np.array(laser3)

                                      # Calculate the FFT for the ground motion signal
    lasfft   = np.fft.fft(gmotion)    # 
    freqlaser = np.fft.fftfreq(len(laser3),delta) # number of samples and delta is the sample rate
                                      #
                                      # Take the rms value of each signal at the main frequency only
                                      #

    sensor_rms = np.abs(np.sqrt(senfft[idx]**2)/(len(freq)/2))
    laser_rms = np.abs(np.sqrt(lasfft[idx]**2)/(len(freq)/2))

                                      # Since the FFT at a single frequency breakpoint is by definition 
                                      # the energy contributed by a sine at that frequency,
                                      # the derivative and integral are related by a factor of 2pi*f
                                      #
                                      # Calculate the equivilant rms value of the derivative and integral 
                                      # of each signal.
                                      # Integral of sensor = sensor / 2pi*f
                                      # Derivative of laser = laser * 2pi*f
                                      # in either case, the ratio works out to sensor_rms/(2pi*f*laser_rms)

    fcal = sensor_rms/(2*np.pi*Frequency*laser_rms) # This is the calibration factor.
                                      #
                                      #     Reset the ground motion back to laser displacement
                                      #     for output 
                                      #
#    laser.rms = laser.rms * gmcorrect

                                      #
                                      #     Calculate the phase difference between input signal and the response
                                      #     not yet implemented
    phase = 0.0

                                      #
                                      #     Output the results to an output file
                                      #     Field 1: Frequency = Frequency (float)
                                      #     Field 2: ccal = Sensor response in V/m/sec
                                      #     Field 3: confidence = confidence in percentage between the two calculation methods.
                                      #     Field 4: phase = Phase difference between the cal coil drive signal and the output
                                      #     Field 5:Name of input file (text)
                                      #
                                      # 
                                      #
#    with open(outfile,'a') as csvfile: # use 'wb' in place of 'a' if you want to overwrite the file.
#        outrow = csv.writer(csvfile, delimiter = ",",
#                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
#        outrow.writerow([Frequency,fcal,infile])
#    print("fcal calculates to: {0:.3f} for frequency {1:.1f} Hz".format(fcal,Frequency))
        
#    with open(outlog,'a') as csvfile:
#        outrow = csv.writer(csvfile, delimiter = ",",
#                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
#        outrow.writerow([Frequency,fcal,infile]) 
    return(Frequency,sensor_rms,laser_rms,fcal,Rn,h,gmcorrect)

             
                                      

#######################################################################################



def main():
                                      #           MAIN PROGRAM BODY
                                      #  Parse the command line switches
                                      # Commmand example: c:\Python27>Python.exe Sigcal.py c:\seismo\caldata\momo
                                      # where momo is the working directory containing the csv files
                                      # as well as the calibration control file, c:\seismo\caldta\calcontrol.csv
                                      # The third option can designate an optional location for the calcontrol file.
                                      #
    optioncount = len(sys.argv)
    outputfile_defined = False
    filelist = []
    dir=""
    infile = ""
    outfile = os.getcwd()+"\calibration_output.cal"
    calfile = os.getcwd()+"\calcontrol.cal"

    if optioncount > 1:

        if optioncount == 4:
            outfile = sys.argv[2]                          # Assume that output file has been designated            

            if '.csv' in sys.argv[3]:                      # If there is a calcontrol set, use it.
                calfile = sys.argv[3]
            else:
                calfile = sys.argv[3]+"\calcontrol.cal" # Assume they pointed at a directory.
            
            if "." in sys.argv[1]:                         
                infile = sys.argv[1]
                filelist.append(infile)
            else:                
                filelist = os.listdir(sys.argv[1])

        if optioncount == 3:                               # No calcontrol designator, but an output file is designated
            calfile = os.getcwd()+"\calcontrol.cal"     # Set the default cal control as current working directory.
            outfile = sys.argv[2]
            
            if "." in sys.argv[1]:                         # Set the input file 
                filelist.append(sys.argv[1])            
            else:
                filelist = os.listdir(sys.argv[1])
                
            
        if optioncount == 2:
            calfile = os.getcwd()+"\calcontrol.cal"
            outfile = os.getcwd()+"\calibration_output.cal"

            if "." in sys.argv[1]:
                infile = sys.argv[1]
                filelist.append(infile)
                
            else:
                calfile = sys.argv[1]+"\calcontrol.cal"
                filelist = os.listdir(sys.argv[1])
                dir = sys.argv[1]+"\\"
    else:
        filelist = os.listdir(os.getcwd())                 # No switches? No problem. Use the current working directory.
        
    print " Cal control file:",calfile
    outlog = outfile+".log"

    constant = getconstants(calfile)
                                                           # 
                                                           # Create the header for the calibration output file.
                                                           # Header contains the station name, ADC cal constants,
                                                           # Laser cal constant, the geometric correction factor,
                                                           # the damping ratio, and the free period frequency.
                                                           #
 
    with open(outfile,'wb') as csvfile: # use 'wb' in place of 'a' if you want to overwrite the file.
        outrow = csv.writer(csvfile, delimiter = ",",
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
        outrow.writerow(constant)
                                                           # Now loop through the directory of csv files to build the
    frequency = []                                     # calibration curve.
    sensor = []
    laser = []
    calnum = []
    filenames = []
    rn = []
    h = []
    gm_correct = []
    print"The length of the file list is {} files.".format(len(filelist))

    for n in range(len(filelist)):                     # Parse through directory for all .csv files
        if ".csv" in filelist[n]:                      # Skip any files that are not a .csv
            infile = dir+filelist[n]                       # Set the input file from the file listing if it is a .csv
            print "Infile set to: ",infile
            (freq,senrms,lasrms,cal,resonance,damprat,gm_c) = process(infile,calfile) # Process the file and output to outfile based on parameters
            frequency.append(freq)
            sensor.append(senrms)
            laser.append(lasrms)
            calnum.append(cal)
            rn.append(resonance)
            h.append(damprat)
            gm_correct.append(gm_c)
            filenames.append(infile)

                                                       # found in calcontrol
    with open(outfile,'a') as csvfile: # use 'wb' in place of 'a' if you want to overwrite the file.
        for n in range(len(frequency)):
            outrow = csv.writer(csvfile, delimiter = ",",
                                quotechar='|', quoting=csv.QUOTE_MINIMAL)
            outrow.writerow([frequency[n],calnum[n],sensor[n],laser[n],rn[n],h[n],gm_correct[n],filenames[n]])
            print("fcal calculates to: {0:.3f} for frequency {1:.2f} Hz".format(calnum[n],frequency[n]))
    # Create the output file
        print("output sent to {} ".format(outfile))
    
                                                           #
                                                           # Now that the file has been created,
                                                           # Bring in the data and plot.                
                                                           #


                                          # Prepare to make the poles and zeroes from Hans Hartse gridsearch algorithm
                                          # Set up the control constants.

    nsearch = 1 # use measured freeperiod # 0: Full constraint on grid search to use MSU-measured amplitudes, damping ratio and free period.
                                          # 1: Optimize for amplitude w/i passband but constrain damping ratio and free period.
                                          # 2: Optimize amplitude w/i passband, optimize damping ratio, but constrain free period.
                                          # 3: Grid search for optimum amplitude, damping ratio AND free period
    coarse_search = 0.10                  # Typically 0.10
    fine_search = 0.005                   # Typically 0.005
    nloops = 5                            # Number of iterations through the grid (typically 4 or 5)
    ngrids = 20                           # Number of steps (typically 20)
    amp_units = "V*sec/m"
    amp_label = "Amplitude [" + amp_units + "]"
    lmult = 2                             # Lower freq. bandpass multiple (typically 2)
    hmult = 5                             # higher freq. bandpass multiple (typically 6)
                                          # Gather the relevant information from the output file
    fdata = load(outfile)
    header = fdata[0]                     # The header contains the initial constants used for creation of the datafile
                                          # and includes the damping ratio, free period frequency, and channel calibration information
                                          # in this order:
    seismometer = fdata[0][0][0]              # Station name
                                          # fdata[0][0][1] # Channel 0 ADC sensitivity in microvolts / count
                                          # fdata[0][0][2] # Channel 1
                                          # fdata[0][0][3] # Channel 2
                                          # fdata[0][0][4] # Channel 3
                                          # fdata[0][0][5] # Laser position sensor in millivolts/micron
                                          # fdata[0][0][6] # Lcalconstant geometry correction factor

    msu_damp = float(fdata[0][0][7])      # h damping ratio
    msu_freep = 1/float(fdata[0][0][8])   # Free period oscillation in Seconds, not Hz (as stored in cal file). 
    freq_msu = []                         # Initialize the frequency array
    amp_msu = []                          # Initialize the matching amplitude array

    for i in range(0,len(fdata[1])):      #        Build the list of frequencies and sensitivities from the file.
        freq_msu.append(float(fdata[1][i][0]))     # Field 0 is the frequency
        amp_msu.append(float(fdata[1][i][1]))      # Field 1 is the average sensitivity

                                #    plot_curve(Station,Frequencies,Sensitivities,Freeperiod,h)
                                #    plot_curve2(Station,Frequencies,Calint,Calderiv,Freeperiod,h)

                                          # Perform the grid search and create the curve

    (resp,best_freep,best_damp,best_scale,amp_average,misfits,misfit_count,best_index) = \
     grid_search.find_pole_zero(freq_msu,amp_msu,seismometer,msu_freep,msu_damp,nsearch,\
     coarse_search,fine_search,nloops,ngrids,lmult,hmult)

                                          # Create the sac poles & zeros file

    sac_pz_file = os.getcwd() +'\\'+ seismometer + '.sacpz' # Set the file name to whatever station name is.
    grid_search.write_sacpz(sac_pz_file,resp)

                                          # Plot the data for the user.

    grid_search.plot_response_curves(resp,freq_msu,amp_msu,best_freep,best_damp,best_scale,\
    msu_freep,msu_damp,amp_average,amp_label,seismometer, sac_pz_file)


#
# Check and run the main function here:
#
if __name__ == '__main__':
  main()