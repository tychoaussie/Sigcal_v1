__author__ = "Daniel Burk <burkdani@msu.edu>"
__version__ = "20140716"
__license__ = "MIT"

import os, sys, csv
from scipy import signal
from scipy.integrate import simps
import pylab as plt
import numpy as np
import scipy as sp


                                           # import time, string
                                           # from obspy.core import read, Trace, Stream, UTCDateTime
                                           # from obspy.sac import SacIO
class Freeperiod(object):
    '''Freeperiod is a utility for converting ascii files generated by 
       the 2010 version of DAT2ASC's csv output that represent a series of transient
       signals which were excited by a calibration coil and recorded simultaneously
       on the seismometer velocity coil and with a laser position sensor that tracks
       actual movement of the seismometer mass. There are two types of transients that
       this program is designed to process: A free-period oscillation in which the 
       damping coil has been disconnected, and a damping ratio measuremnet transient
       in which the damping coil is connected. Both transients will result in a decaying
       sinusoidal signal; This program will return a file with measurement of an average
       oscillation frequency, an average damping ratio representing the first three
       oscillations of the transient, followed by a table of measured periods until the
       peak oscillation drops below -18dB (12.5%) of the peak amplitude of the initial 
       peak transient.
       
        

       Syntax: freeperiod target_directory (outfile_name) (calconst.cal_alternate_name) 

       

       Typical useage:
       <ObsPy> C:\Python27\scripts> python freeperiod.py c:/calibration/station/ [outfputfile] [calconstfile]

    '''

                                   #                       Function load:
 
                                   # load the csv infile as generated by DAT2ASC with csv option
def load(infile):                                    
    with open(infile,'r') as fin:
        list = csv.reader(fin)
        rowcnt=0
        stack = []
        header = []
        for row in list:           # Bring in the data and create a list of lists, each of which                                  
            if rowcnt == 0:        # corresponds with a given sample.
                header.append(row)
            else:
                stack.append(row)
            rowcnt = 1
    return (header,stack)

                                   #                       Function getconstants:

def getconstants(calcontrol):      # From calcontrol file, retrieve the list of constants 
    constants = load(calcontrol)   # that relate these measurements to the real world.
    constant = constants[1][0]        # constants[0] contains headers that we don't really use
                                   # constant[0] = (text) Station: 'station name'
                                   # constant[1] = (float) adccal[0]: cal constant for ch 0 (microvolts / count)
                                   # constant[2] = (float) adccal[1]: cal constant for ch 1 (microvolts / count)
                                   # constant[3] = (float) adccal[2]: cal constant for ch 2 (microvolts / count)
                                   # constant[4] = (float) adccal[3]: cal constant for ch 3 (microvolts / count)
                                   # constant[5] = (float) laserres: cal constant for the laser ( mV / micron)
                                   # constant[6] = (float) lcalconst: cal constant for geometry correction factor
                                   # constant[7] = (float) h: Damping ratio for the seismometer as measured by engineer.
                                   # constant[8] = (float) resfreq: Free period resonance freq. as measured by engineer.
    return(constant)


def scatter_comparison():
    '''exponential function, y = exp(0.05 x)'''
 
    # prepare data points
    # plot it
    
    plt.loglog(F1, S1, "*", F2, S2, "+") #, F3, S3, "*")     # the "." means draw points instead of lines
    plt.xlabel("Frequency")
    plt.ylabel("Sensitivity in V/m/sec")
    plt.title("Comparison of sensitivity curves")
    plt.annotate("* = derivative data", xy=(10,5), xytext=(3,1),
                 arrowprops=dict(facecolor='black',shrink=0.05))
    plt.annotate("+ = integral data", xy=(.1,.1), xytext=(1,.1),
                 arrowprops=dict(facecolor='green',shrink=0.05))
#    plt.annotate("* = Signal hybrid", xy = (.1,.1), xytext = (1,.01),
#                 arrowprops=dict(facecolor='red',shrink=0.05))
    plt.show()
    
def graph_curve(time,counts,resfreq):
    plt.plot(time,counts)
    plt.xlabel("Time (in seconds)    Free period frequency = {:.3f} Hz".format(resfreq))
    plt.ylabel("Counts")
    plt.show()

def graph_curve2(X,Y,Ylabel,Y1,ylabel1):
    plt.plot(X,Y, '-b', label = Ylabel)
    plt.plot(X,Y1, '-r', label = Ylabel1)
    plt.xlabel("Samples")
    plt.ylabel("Counts")
    plt.show()

def process(infile,calfile):

    fdata = load(infile)     # Load the infile currently loaded with 1 Hz data
    header = fdata[0]
    adccal = [1.0,1.0,1.0,1.0]

    constant = getconstants(calfile)         # Retrieve the constants from the file

    Station = constant[0]                    # Name of Station under test
    for i in range(0,4):
        adccal[i] = float(constant[i+1])     # Calibration constants for the ADC channels as measured by engineer
                                             # for this particular system. Each one is unique.
    laserres = float(constant[5])            # CALIBRATED value from laser position sensor in mV/micron
    lcalconst = float(constant[6])           # Typ. 1.022, for the SM3, based on the geometry of the laser target 
                                             # and center of coil relative to radius of moment arm
    h = float(constant[7])                   # typically about 0.7 but MUST be accurately measured beforehand!
    resfreq = float(constant[8])             # Typically between 0.7 and 1.3 Hz. Expressed in Hz, not seconds.
    Rn = (np.pi * 2.0 * resfreq)             # Free period as expressed in radians / second                      
    lasercal = laserres/1000                 # microns / count from the CALIBRATED laser and CALIBRATED ADC.
                                             # Parse out the sensor and laser data
#    sensor = [] 
#    laser = []
    ch0 = []
    ch1 = []
    ch2 = []
    ch3 = []
    for i in range(0,len(fdata[1])):
        ch0.append(int(fdata[1][i][1], base=10))
        ch1.append(int(fdata[1][i][1], base=10))
        ch2.append(int(fdata[1][i][1], base=10))
        ch3.append(int(fdata[1][i][1], base=10))
#        laser.append(int(fdata[1][i][4], base=10))

                                             # Calculate the sample period based on the timing channels (in seconds)

    delta = ((float(fdata[1][len(fdata[1])-1][12])+float(fdata[1][len(fdata[1])-1][15]))-(float(fdata[1][0][12])+float(fdata[1][0][15])))/len(fdata[1])

        # laser = sp.signal.symiirorder1(laser,4,.8) # Adjust the signal for DC bias of laser, then filter.
#    lasermean = np.mean(laser[(len(laser)-2048):len(laser)]) # Take the DC bias measurement fm end of signal
#    laser[:] = [x-int(lasermean) for x in laser]
                                      #
                                      # I am not yet able to auto process these files
                                      # Therefore we'll open the graph, plot the whole waveform
                                      # and let the user pick the starting sample point.
                                      # Then we'll process frequency from there.


#    x = []
#    for i in range (0,len(laser)):
#        x.append(i)
#    plt.plot(x,laser)
#    plt.show()

#    start =int(raw_input('Enter the estimated sample number of the beginning of the impulse  '))
    # print 'start = {}'.format(start)
#    end =int(raw_input('Enter the estimated sample number of the ending of the impulse train '))
#    end = start+8192
        ##########################################################
                                      # Find the beginning and ending of the waveform and return those values
                                      # Using the derivative, flag the point where derivative is at its highest magnitude.
                                      # This should be the point of onset for the first impulse.
#    print np.mean(laser),len(laser)
#     lgrad = np.array(laser,dtype=np.float)                          #
#    lgrad = derivative(laser)
    #  lgrad2 = np.gradient(lgrad,80)
#    lgfilt = sp.signal.symiirorder1(lgrad,4,.8) 
                                      # clean up the derivative a little
#    dg = [] 
                                      # Create an x axis that represents elapsed time in seconds. 
                                      # delta = seconds per sample, i represents sample count
#    for i in range(0,len(laser)):
#        dg.append(i*delta)

#    start = (np.where(abs(lgfilt)==max(np.abs(lgfilt)))) # return the element number of highest derivative

#    print "Start of waveform is calculated as occurring at sample {} . ".format(start)
#    print start[0][0]    

    

    ##########################################################
                                      #            
                                      # Find the period of the observed signal
                                      #


#    sense = laser[start:end]   # 2466:(2466+4096)]
                                      # sense = sense[:]
#   N = len(sense)
    W0    = np.fft.fft(ch0)
    W1    = np.fft.fft(ch1)
    W2    = np.fft.fft(ch2)
    W3    = np.fft.fft(ch3)
    F0 = np.fft.fftfreq(len(ch0),delta)
    F1 = np.fft.fftfreq(len(ch1),delta)
    F2 = np.fft.fftfreq(len(ch2),delta)
    F3 = np.fft.fftfreq(len(ch3),delta)

                                      # First value represents the number of samples and delta is the sample rate

                                      #
                                      # Take the sample with the largest amplitude as our center frequency. 
                                      # This only works if the signal is heavily sinusoidal and stationary 
                                      # in nature, like our calibration data.
                                      #

#   idx = np.where(abs(W)==max(np.abs(W)))[0][-1]
#   Frequency = abs(freq[idx])        # Frequency in Hz
#   print Frequency, delta
#   period = 1/(Frequency*delta)      # represents the number of samples for one cycle of the test signal.

                                      # gmcorrect = (2*np.pi*Frequency)**2/np.sqrt((Rn**2-(2*np.pi*Frequency)**2)**2+(4*h**2*(2*np.pi*Frequency)**2*Rn**2))
                                      #
                                      # create an axis representing time.
                                      #

#   dt = [] # Create an x axis that represents elapsed time in seconds. delta = seconds per sample, i represents sample count
#   for i in range(0,len(sense)):
#       dt.append(i*delta)

                                      # gmcorrect is the correction factor for observed pendulum motion 
                                      # vs true ground motion.
                                      # 
                                      #
                                      # At this point, we know the frequency interval, the delta, and we have the arrays 
                                      # for signal and laser. We can now piecewise adjust the signals for a 3* their period 
                                      # for DC offset. Adjust sensor and laser for linear trend removal, then apply an 
                                      # optional filter. Then apply calibration constants to yield units of microvolts 
                                      # for sensor, and units of microns for the laser position sensor.
    for j in range(0,4):                                      #
        x = []
        for i in range(0,len(sense)):
            x.append(i*delta)
        graph_curve(x,sense,Frequency)

        print 'Frequency calculated to ',Frequency,' Hz.' 







def main():
                                      #           MAIN PROGRAM BODY
                                      #  Parse the command line switches
                                      # Commmand example: c:\Python27>Python.exe Sigcal.py c:\seismo\caldata\momo
                                      # where momo is the working directory containing the csv files
                                      # as well as the calibration control file, c:\seismo\caldta\calcontrol.csv
                                      # The third option can designate an optional location for the calcontrol file.
                                      #
    optioncount = len(sys.argv)
    outputfile_defined = False
    filelist = []
    dir=""

    outfile = os.getcwd()+"\fft.cal"
    calfile = os.getcwd()+"\calcontrol.cal"

    if optioncount > 1:

           
        if optioncount == 2:
            calfile = os.getcwd()+"\calcontrol.cal"

            if "." in sys.argv[1]:
                infile = sys.argv[1]

    else:
        filelist = os.listdir(os.getcwd())                 # No switches? No problem. Use the current working directory.
        infile = filelist[0]


        print " This program requires that you input a file representing the free period resonance."
        constant = getconstants(calfile)
    
    process(infile,calfile)                                                     


#
# Check and run the main function here:
#
if __name__ == '__main__':
  main()
